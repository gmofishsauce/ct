Pull app together:

DONE App needs a text box with a button next to it and a status bar.
Startup:
    DONE send fixed initialization to server.
DONE If not responding:
    DONE message in status bar, button says "start", text box gray.
LATER (text UI is adequate for now): When server connection:
    pale "startpos" message in status bar, button says "Go!".
    click button -> startpos to server
    FEN into text box, click button -> FEN to server
Running (for now)
    arrow keys move between hexes
    enter/return centers on the selected hex
    there is no "blowout" to more hexes yet.

Initially set MultiPV = 6

Right click on center object: no action - it's dead.
Right click on hex at distance 1 from center:
    three menu items: "Expand Left", "Expand Right", and "Center"
    At distance 2, on any of the 12 possible nodes, you just get "Center".
Hexes at distance > 2 freeze (color = light blue) at last recorded vertical scale.

Implementation
Better put the vertical scale factors on the objects first.
Then, put the object's {q, r} on the object.

Not clear
Can I put ALL the indexing stuff on the objects and just have a "sea of objects"
OR do I need to access objects by some kind of index.

Ah - I only need to access hexcyls by index when updating from Stockfish.
So each running Stockfish instance needs to know its "zero" object,
    and the objects indexed by its traces have to be "contiguous".

So, ah ah - An unordered sea of hexcyls with an ordered array of hexcyls
    references (indices? pointers? what?) used at Stockfish update time.

Bottom line:
DONE Finish basic mouse selection ("demo")
DONE Put actual and target scales on the objects
???? Move existing demo to a sea of objects with one mapping array
???? Add a second Stockfish instance and make sure nothing breaks
???? Change the mapping arrays to be associated with the Stockfish instances


More about the model (9/23/2025):
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DONE I need to put {q, r} on the nameless objects returned by makeCylWithLabel().
Reduce initial display to just the center cylinder.
Add a function requireHexcyl(...) that either makes a new hexcyl at {q, r}
    or returns the existing hexcyl.
???? There will be one primary server (MultiPV = 6) and N secondaries (MultiPV = 3)
???? N will be a parameter with a default value, eventually a "Settings..." button
???? [ side note: mouse over hexcyl => put FEN in text box "for real" ]
???? [ side note: try showing just the centered node on the chessboard ]
???? clicking on centered node does nothing
???? single click on non-centered node starts a secondary centered on that node
???? double click on non-centered node centers that node, freezing some node(s).

Simplification:
There is just one kind of click, "expand"
It recenters the server and expands into all unused adjacent hexes, usually 3.
All the other hexcyls become abandoned (need visual indication).
I still need requireHexcyl() based on the exposed (q, r) coordinates as above.
When hexcyl click:
    clear the "active" (array of active hexcyl references)
    stop the engine
    iterator neighbors of selected hexcyl:
        if doesn't exist:
            create and add to "active"
    reorder active so that the 1-line is northeast-most, etc.
    start the engine with MultiPV = len(active)
when "Go" click:
    All of hexcyl click but ALSO clean the "ocean" (and remove all from scene)

? All hexcyls (aside "Start") are created by requireHexcyl from updateView().
? Created hexcyls are always added to both the ocean[] and active[].

CORRECTION: the "ocean" will never be cleared of hexcyls, but hexcyls can
be removed from the scene with scene.remove(). All hexcyls ever created will
exist until program (page) termination. All hexcyls will be created by
requireHexcyl(), which will first check the ocean[] for unused elements
and "repurpose" them if they exist. In practice hexcyls are only removed
from the scene when they are all removed, at which point all the hexcyls
will be removed from the scene and serially reallocated as the scene refills.

